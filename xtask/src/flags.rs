use std::path::PathBuf;

xflags::xflags! {
    src "./src/flags.rs"
    /// xtask is a tool for building and testing the project
    cmd xtask {
        /// 编译所有合约到output目录
        cmd build
        {
            /// 你可以指定一个output目录，默认为./output
            optional -o,--output output: PathBuf
            /// 默认为debug模式
            optional --debug
            /// 可以指定为release模式
            optional -r,--release
            /// 默认为quiet模式
            optional -q,--quiet
            /// 可以指定为verbose模式
            optional -v,--verbose
            /// 指定输出所有
            optional -a,--all
        }
    }
}
// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    Build(Build),
}

#[derive(Debug)]
pub struct Build {
    pub output: Option<PathBuf>,
    pub debug: bool,
    pub release: bool,
    pub quiet: bool,
    pub verbose: bool,
    pub all: bool,
}

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
