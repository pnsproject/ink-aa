use std::path::PathBuf;

xflags::xflags! {
    src "./src/flags.rs"
    /// xtask 是一个用于构建和测试项目的工具
    cmd xtask {
        /// 编译所有合约到 output 目录
        cmd build
        {
            /// 可选参数，指定编译输出目录，默认为 ./output
            optional -o,--output output: PathBuf
            /// 可选参数，指定编译模式为 debug 模式，默认为 debug 模式
            optional --debug
            /// 可选参数，指定编译模式为 release 模式
            optional -r,--release
            /// 可选参数，指定输出信息的模式为安静模式，默认为安静模式
            optional -q,--quiet
            /// 可选参数，指定输出信息的模式为详细模式
            optional -v,--verbose
            /// 可选参数，指定输出所有信息
            optional -a,--all
        }
        cmd deploy {
            /// 必选参数，指定部署合约的账户的密钥 URI
            required -s, --suri suri: PathBuf
            /// 可选参数，指定输出目录，默认为 ./output
            optional directory: PathBuf
            /// 可选参数，指定 substrate 节点的 Websockets URL，默认为 ws://localhost:9944
            optional --url url: String
            /// 可选参数，指定调用者最多可以支付的存储费用限制
            optional --storage-deposit-limit STORAGE_DEPOSIT_LIMIT: u128
            /// 可选参数，指定密钥的密码
            optional -p, --password password: String
        }
    }
}
// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    Build(Build),
    Deploy(Deploy),
}

#[derive(Debug)]
pub struct Build {
    pub output: Option<PathBuf>,
    pub debug: bool,
    pub release: bool,
    pub quiet: bool,
    pub verbose: bool,
    pub all: bool,
}

#[derive(Debug)]
pub struct Deploy {
    pub directory: Option<PathBuf>,

    pub suri: PathBuf,
    pub url: Option<String>,
    pub storage_deposit_limit: Option<u128>,
    pub password: Option<String>,
}

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end
